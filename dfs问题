题目描述：
GeoSurvComp地质探测公司负责探测地下油田。每次GeoSurvComp公司都是在一块长方形的土地上来探测油田。在探测时，他们把这块土地用网格分成若干个小块，然后逐个分析每块土地，用探测设备探测地下是否有油田。土地底下有油田则成为pocket，如果两个pocket相邻，则认为是同一块油田，油田可能覆盖多个pocket。试计算长方形的土地上有多少个不同的油田。
输入描述：
输入文件中包含多个测试数据，每个测试数据描述了一个网格。每个网格数据的第1行为两个整数：m、n，分别表示网格的行和列；如果m=0，则表示输入结束，否则1<=m<=100，1<=n<=100。接下来有m行数据，每行数据有n个字符（不包括行结束符）。每个字符代表一个小方块，如果为“*”，则代表没有石油，如果为“@”，则代表有石油，是一个pocket。
输出描述：
对输入文件中的每个网格，输出网格中不同的油田数目。如果两块不同的pocket在水平、垂直或者对角线方向上相邻，则被认为属于同一块油田。每块油田所包含的pocket数目不会超过100。
样例输入：
5 5
****@
*@@*@
*@**@
@@@*@
@@**@
样例输出：
2

#include<stdio.h>
#include<string.h>
#define max 101
char grid[max][max];
int dir[8][2]={{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};
//dir方向数组，-1代表减一行或减一列， 0代表在该行或该列不改变，1代表增1行或增1列
int m,n;
void dfs(int x , int y)
{
    int xx,yy,i;
    grid[x][y]='*'; //给判断过的下标去掉。
    for (i=0;i<8;i++)
    {
        xx=x + dir[i][0];
        yy=y + dir[i][1];
        //xx,yy为生成的新的方向grid的数组下标
        if (xx>=m||xx<0||yy>=n||yy<0)  //出界就重新搜索下一个方向，不用再去判断了
            continue;
        if (grid[xx][yy] == '@')
            dfs(xx,yy);
    }
}

int main()
{
    int i,j,cnt=0;
    while (scanf("%d%d",&m,&n)==2)
    {
        cnt=0;
        if (m==0&&n==0)//输入两个0，结束程序
            break;
        memset(grid,0,sizeof(grid));
        for (i=0;i<m;i++)
            scanf("%s",grid[i]);  // 网格输入
        for (i=0;i<m;i++)
        {
            for (j=0;j<n;j++)
                if (grid[i][j]=='@') //将是@的发送到dfs中，查找该坐标下的8个方向的@
                {
                    dfs(i,j);
                    cnt++;  //油田数
                }
        }
        printf("%d",cnt);
    }
}
